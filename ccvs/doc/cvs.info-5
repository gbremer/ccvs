This is cvs.info, produced by makeinfo version 4.5 from cvs.texinfo.

INFO-DIR-SECTION GNU Packages
START-INFO-DIR-ENTRY
* CVS: (cvs).                   Concurrent Versions System
END-INFO-DIR-ENTRY
INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* cvs: (cvs)CVS commands.       Concurrent Versions System
END-INFO-DIR-ENTRY


File: cvs.info,  Node: Getting Notified,  Next: Editing files,  Prev: Setting a watch,  Up: Watches

Telling CVS to notify you
-------------------------

   You can tell CVS that you want to receive notifications about
various actions taken on a file.  You can do this without using `cvs
watch on' for the file, but generally you will want to use `cvs watch
on', to remind developers to use the `cvs edit' command.

 - Command: cvs watch add [`-lR'] [`-a' ACTION]... [FILES]...
     Add the current user to the list of people to receive notification
     of work done on FILES.

     The `-a' option specifies what kinds of events CVS should notify
     the user about.  ACTION is one of the following:

    `edit'
          Another user has applied the `cvs edit' command (described
          below) to a watched file.

    `commit'
          Another user has committed changes to one of the named FILES.

    `unedit'
          Another user has abandoned editing a file (other than by
          committing changes).  They can do this in several ways, by:

             * applying the `cvs unedit' command (described below) to
               the file

             * applying the `cvs release' command (*note release::) to
               the file's parent directory (or recursively to a
               directory more than one level up)

             * deleting the file and allowing `cvs update' to recreate
               it


    `all'
          All of the above.

    `none'
          None of the above.  (This is useful with `cvs edit',
          described below.)


     The `-a' option may appear more than once, or not at all.  If
     omitted, the action defaults to `all'.

     The FILES and options are processed as for `cvs watch on'.


 - Command: cvs watch remove [`-lR'] [`-a' ACTION]... [FILES]...
     Remove a notification request established using `cvs watch add';
     the arguments are the same.  If the `-a' option is present, only
     watches for the specified actions are removed.


   When the conditions exist for notification, CVS calls the `notify'
administrative file.  Edit `notify' as one edits the other
administrative files (*note Intro administrative files::).  This file
follows the usual conventions for administrative files (*note
syntax::), where each line is a regular expression followed by a
command to execute.  The command should contain a single occurrence of
`%s' which will be replaced by the user to notify; the rest of the
information regarding the notification will be supplied to the command
on standard input.  The standard thing to put in the `notify' file is
the single line:

     ALL mail %s -s "CVS notification"

This causes users to be notified by electronic mail.

   Note that if you set this up in the straightforward way, users
receive notifications on the server machine.  One could of course write
a `notify' script which directed notifications elsewhere, but to make
this easy, CVS allows you to associate a notification address for each
user.  To do so create a file `users' in `CVSROOT' with a line for each
user in the format USER:VALUE.  Then instead of passing the name of the
user to be notified to `notify', CVS will pass the VALUE (normally an
email address on some other machine).

   CVS does not notify you for your own changes.  Currently this check
is done based on whether the user name of the person taking the action
which triggers notification matches the user name of the person getting
notification.  In fact, in general, the watches features only track one
edit by each user.  It probably would be more useful if watches tracked
each working directory separately, so this behavior might be worth
changing.


File: cvs.info,  Node: Editing files,  Next: Watch information,  Prev: Getting Notified,  Up: Watches

How to edit a file which is being watched
-----------------------------------------

   Since a file which is being watched is checked out read-only, you
cannot simply edit it.  To make it read-write, and inform others that
you are planning to edit it, use the `cvs edit' command.  Some systems
call this a "checkout", but CVS uses that term for obtaining a copy of
the sources (*note Getting the source::), an operation which those
systems call a "get" or a "fetch".

 - Command: cvs edit [`-lR'] [`-a' ACTION]... [FILES]...
     Prepare to edit the working files FILES.  CVS makes the FILES
     read-write, and notifies users who have requested `edit'
     notification for any of FILES.

     The `cvs edit' command accepts the same options as the `cvs watch
     add' command, and establishes a temporary watch for the user on
     FILES; CVS will remove the watch when FILES are `unedit'ed or
     `commit'ted.  If the user does not wish to receive notifications,
     she should specify `-a none'.

     The FILES and the options are processed as for the `cvs watch'
     commands.

     There are two additional options that `cvs edit' understands as of
     CVS client and server versions 1.12.10 but `cvs watch' does not.
     The first is `-c', which causes `cvs edit' to fail if anyone else
     is editting the file.  This is probably only useful when `edit -c'
     and `commit -c' are specified in all developers' `.cvsrc' files.
     This behavior may be overriden this via the `-f' option, which
     overrides `-c' and allows multiple edits to succeed.


   Normally when you are done with a set of changes, you use the `cvs
commit' command, which checks in your changes and returns the watched
files to their usual read-only state.  But if you instead decide to
abandon your changes, or not to make any changes, you can use the `cvs
unedit' command.

 - Command: cvs unedit [`-lR'] [FILES]...
     Abandon work on the working files FILES, and revert them to the
     repository versions on which they are based.  CVS makes those
     FILES read-only for which users have requested notification using
     `cvs watch on'.  CVS notifies users who have requested `unedit'
     notification for any of FILES.

     The FILES and options are processed as for the `cvs watch'
     commands.

     If watches are not in use, the `unedit' command probably does not
     work, and the way to revert to the repository version is with the
     command `cvs update -C file' (*note update::).  The meaning is not
     precisely the same; the latter may also bring in some changes
     which have been made in the repository since the last time you
     updated.

   When using client/server CVS, you can use the `cvs edit' and `cvs
unedit' commands even if CVS is unable to successfully communicate with
the server; the notifications will be sent upon the next successful CVS
command.


File: cvs.info,  Node: Watch information,  Next: Watches Compatibility,  Prev: Editing files,  Up: Watches

Information about who is watching and editing
---------------------------------------------

 - Command: cvs watchers [`-lR'] [FILES]...
     List the users currently watching changes to FILES.  The report
     includes the files being watched, and the mail address of each
     watcher.

     The FILES and options are processed as for the `cvs watch'
     commands.


 - Command: cvs editors [`-lR'] [FILES]...
     List the users currently working on FILES.  The report includes
     the mail address of each user, the time when the user began
     working with the file, and the host and path of the working
     directory containing the file.

     The FILES and options are processed as for the `cvs watch'
     commands.



File: cvs.info,  Node: Watches Compatibility,  Prev: Watch information,  Up: Watches

Using watches with old versions of CVS
--------------------------------------

   If you use the watch features on a repository, it creates `CVS'
directories in the repository and stores the information about watches
in that directory.  If you attempt to use CVS 1.6 or earlier with the
repository, you get an error message such as the following (all on one
line):

     cvs update: cannot open CVS/Entries for reading:
     No such file or directory

and your operation will likely be aborted.  To use the watch features,
you must upgrade all copies of CVS which use that repository in local
or server mode.  If you cannot upgrade, use the `watch off' and `watch
remove' commands to remove all watches, and that will restore the
repository to a state which CVS 1.6 can cope with.


File: cvs.info,  Node: Choosing a model,  Prev: Watches,  Up: Multiple developers

Choosing between reserved or unreserved checkouts
=================================================

   Reserved and unreserved checkouts each have pros and cons.  Let it
be said that a lot of this is a matter of opinion or what works given
different groups' working styles, but here is a brief description of
some of the issues.  There are many ways to organize a team of
developers.  CVS does not try to enforce a certain organization.  It is
a tool that can be used in several ways.

   Reserved checkouts can be very counter-productive.  If two persons
want to edit different parts of a file, there may be no reason to
prevent either of them from doing so.  Also, it is common for someone
to take out a lock on a file, because they are planning to edit it, but
then forget to release the lock.

   People, especially people who are familiar with reserved checkouts,
often wonder how often conflicts occur if unreserved checkouts are
used, and how difficult they are to resolve.  The experience with many
groups is that they occur rarely and usually are relatively
straightforward to resolve.

   The rarity of serious conflicts may be surprising, until one realizes
that they occur only when two developers disagree on the proper design
for a given section of code; such a disagreement suggests that the team
has not been communicating properly in the first place.  In order to
collaborate under _any_ source management regimen, developers must
agree on the general design of the system; given this agreement,
overlapping changes are usually straightforward to merge.

   In some cases unreserved checkouts are clearly inappropriate.  If no
merge tool exists for the kind of file you are managing (for example
word processor files or files edited by Computer Aided Design
programs), and it is not desirable to change to a program which uses a
mergeable data format, then resolving conflicts is going to be
unpleasant enough that you generally will be better off to simply avoid
the conflicts instead, by using reserved checkouts.

   The watches features described above in *Note Watches:: can be
considered to be an intermediate model between reserved checkouts and
unreserved checkouts.  When you go to edit a file, it is possible to
find out who else is editing it.  And rather than having the system
simply forbid both people editing the file, it can tell you what the
situation is and let you figure out whether it is a problem in that
particular case or not.  Therefore, for some groups watches can be
considered the best of both the reserved checkout and unreserved
checkout worlds.

   As of CVS client and server versions 1.12.10, you may also enable
advisory locks by putting `edit -c' and `commit -c' in all developers'
`.cvsrc' files.  After this is done, `cvs edit' will fail if there are
any other editors, and `cvs commit' will fail if the committer has not
registered to edit the file via `cvs edit'.  This is most effective in
conjunction with files checked out read-only by default, which may be
enabled by turning on watches in the repository or by putting `cvs -r'
in all `.cvsrc' files.


File: cvs.info,  Node: Revision management,  Next: Keyword substitution,  Prev: Multiple developers,  Up: Top

Revision management
*******************

   If you have read this far, you probably have a pretty good grasp on
what CVS can do for you.  This chapter talks a little about things that
you still have to decide.

   If you are doing development on your own using CVS you could
probably skip this chapter.  The questions this chapter takes up become
more important when more than one person is working in a repository.

* Menu:

* When to commit::              Some discussion on the subject


File: cvs.info,  Node: When to commit,  Up: Revision management

When to commit?
===============

   Your group should decide which policy to use regarding commits.
Several policies are possible, and as your experience with CVS grows
you will probably find out what works for you.

   If you commit files too quickly you might commit files that do not
even compile.  If your partner updates his working sources to include
your buggy file, he will be unable to compile the code.  On the other
hand, other persons will not be able to benefit from the improvements
you make to the code if you commit very seldom, and conflicts will
probably be more common.

   It is common to only commit files after making sure that they can be
compiled.  Some sites require that the files pass a test suite.
Policies like this can be enforced using the commitinfo file (*note
commitinfo::), but you should think twice before you enforce such a
convention.  By making the development environment too controlled it
might become too regimented and thus counter-productive to the real
goal, which is to get software written.


File: cvs.info,  Node: Keyword substitution,  Next: Tracking sources,  Prev: Revision management,  Up: Top

Keyword substitution
********************

   As long as you edit source files inside a working directory you can
always find out the state of your files via `cvs status' and `cvs log'.
But as soon as you export the files from your development environment
it becomes harder to identify which revisions they are.

   CVS can use a mechanism known as "keyword substitution" (or "keyword
expansion") to help identifying the files.  Embedded strings of the form
`$KEYWORD$' and `$KEYWORD:...$' in a file are replaced with strings of
the form `$KEYWORD:VALUE$' whenever you obtain a new revision of the
file.

* Menu:

* Keyword list::                   Keywords
* Using keywords::                 Using keywords
* Avoiding substitution::          Avoiding substitution
* Substitution modes::             Substitution modes
* Configuring keyword expansion::  Configuring keyword expansion
* Log keyword::                    Problems with the $Log$ keyword.


File: cvs.info,  Node: Keyword list,  Next: Using keywords,  Up: Keyword substitution

Keyword List
============

   This is a list of the keywords:

`$Author$'
     The login name of the user who checked in the revision.

`$CVSHeader'
     A standard header (similar to $Header$, but with the CVS root
     stripped off). It contains the relative pathname of the RCS file
     to the CVS root, the revision number, the date (UTC), the author,
     the state, and the locker (if locked). Files will normally never
     be locked when you use CVS.

     Note that this keyword has only been recently introduced to CVS
     and may cause problems with existing installations if $CVSHeader$
     is already in the files for a different purpose. This keyword may
     be excluded using the `KeywordExpansion=eCVSHeader' in the
     `CVSROOT/config' file.  See *Note Configuring keyword expansion::
     for more details.

`$Date$'
     The date and time (UTC) the revision was checked in.

`$Header$'
     A standard header containing the full pathname of the RCS file,
     the revision number, the date (UTC), the author, the state, and
     the locker (if locked).  Files will normally never be locked when
     you use CVS.

`$Id$'
     Same as `$Header$', except that the RCS filename is without a path.

`$Name$'
     Tag name used to check out this file.  The keyword is expanded
     only if one checks out with an explicit tag name.  For example,
     when running the command `cvs co -r first', the keyword expands to
     `Name: first'.

`$Locker$'
     The login name of the user who locked the revision (empty if not
     locked, which is the normal case unless `cvs admin -l' is in use).

`$Log$'
     The log message supplied during commit, preceded by a header
     containing the RCS filename, the revision number, the author, and
     the date (UTC).  Existing log messages are _not_ replaced.
     Instead, the new log message is inserted after `$Log:...$'.  By
     default, each new line is prefixed with the same string which
     precedes the `$Log$' keyword, unless it exceeds the
     `MaxCommentLeaderLength' set in `CVSROOT/config'.

     For example, if the file contains:

            /* Here is what people have been up to:
             *
             * $Log: frob.c,v $
             * Revision 1.1  1997/01/03 14:23:51  joe
             * Add the superfrobnicate option
             *
             */

     then additional lines which are added when expanding the `$Log$'
     keyword will be preceded by `   * '.  Unlike previous versions of
     CVS and RCS, the "comment leader" from the RCS file is not used.
     The `$Log$' keyword is useful for accumulating a complete change
     log in a source file, but for several reasons it can be
     problematic.

     If the prefix of the `$Log$' keyword turns out to be longer than
     `MaxCommentLeaderLength', CVS will skip expansion of this keyword
     unless `UseArchiveCommentLeader' is also set in `CVSROOT/config'
     and a `comment leader' is set in the RCS archive file, in which
     case the comment leader will be used instead.  For more on setting
     the comment leader in the RCS archive file, *Note admin::.  For
     more on configuring the default `$Log$' substitution behavior,
     *Note config::.

     *Note Log keyword::.

`$RCSfile$'
     The name of the RCS file without a path.

`$Revision$'
     The revision number assigned to the revision.

`$Source$'
     The full pathname of the RCS file.

`$State$'
     The state assigned to the revision.  States can be assigned with
     `cvs admin -s'--see *Note admin options::.

`Local keyword'
     The `LocalKeyword' option in the `CVSROOT/config' file may be used
     to specify a local keyword which is to be used as an alias for one
     of the other keywords. For example, if the `CVSROOT/config' file
     contains a line with `LocalKeyword=MYBSD=CVSHeader', then a file
     with the local keyword $MYBSD$ will be expanded as if it were a
     $CVSHeader$ keyword. If the src/frob.c file contained this
     keyword, it might look something like this:

            /*
             * $MYBSD: src/frob.c,v 1.1 2003/05/04 09:27:45 john Exp $
             */

     Many repositories make use of a such a "local keyword" feature. An
     old patch to CVS provided the `LocalKeyword' feature using a `tag='
     option and called this the "custom tag" or "local tag" feature. It
     was used in conjunction with the what they called the `tagexpand='
     option. In CVS this other option is known as the `KeywordExpand'
     option.  See *Note Configuring keyword expansion:: for more
     details.

     Examples from popular projects include: $FreeBSD$, $NetBSD$,
     $OpenBSD$, $XFree86$, $Xorg$.

     The advantage of this is that you can include your local version
     information in a file using this local keyword without disrupting
     the upstream version information (which may be a different local
     keyword or a standard keyword). Allowing bug reports and the like
     to more properly identify the source of the original bug to the
     third-party and reducing the number of conflicts that arise during
     an import of a new version.

     All keyword expansion except the local keyword may be disabled
     using the `KeywordExpansion' option in the `CVSROOT/config'
     file--see *Note Configuring keyword expansion:: for more details.



File: cvs.info,  Node: Using keywords,  Next: Avoiding substitution,  Prev: Keyword list,  Up: Keyword substitution

Using keywords
==============

   To include a keyword string you simply include the relevant text
string, such as `$Id$', inside the file, and commit the file.  CVS will
automatically (Or, more accurately, as part of the update run that
automatically happens after a commit.)  expand the string as part of
the commit operation.

   It is common to embed the `$Id$' string in the source files so that
it gets passed through to generated files.  For example, if you are
managing computer program source code, you might include a variable
which is initialized to contain that string.  Or some C compilers may
provide a `#pragma ident' directive.  Or a document management system
might provide a way to pass a string through to generated files.

   The `ident' command (which is part of the RCS package) can be used
to extract keywords and their values from a file.  This can be handy
for text files, but it is even more useful for extracting keywords from
binary files.

     $ ident samp.c
     samp.c:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
     $ gcc samp.c
     $ ident a.out
     a.out:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $

   SCCS is another popular revision control system.  It has a command,
`what', which is very similar to `ident' and used for the same purpose.
Many sites without RCS have SCCS.  Since `what' looks for the
character sequence `@(#)' it is easy to include keywords that are
detected by either command.  Simply prefix the keyword with the magic
SCCS phrase, like this:

     static char *id="@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";


File: cvs.info,  Node: Avoiding substitution,  Next: Substitution modes,  Prev: Using keywords,  Up: Keyword substitution

Avoiding substitution
=====================

   Keyword substitution has its disadvantages.  Sometimes you might
want the literal text string `$Author$' to appear inside a file without
CVS interpreting it as a keyword and expanding it into something like
`$Author: ceder $'.

   There is unfortunately no way to selectively turn off keyword
substitution.  You can use `-ko' (*note Substitution modes::) to turn
off keyword substitution entirely.

   In many cases you can avoid using keywords in the source, even
though they appear in the final product.  For example, the source for
this manual contains `$@asis{}Author$' whenever the text `$Author$'
should appear.  In `nroff' and `troff' you can embed the null-character
`\&' inside the keyword for a similar effect.

   It is also possible to specify an explicit list of keywords to
include or exclude using the `KeywordExpand' option in the
`CVSROOT/config' file-see *Note Configuring keyword expansion:: for
more details. This feature is intended primarily for use with the
`LocalKeyword' option-see *Note Keyword list::.


File: cvs.info,  Node: Substitution modes,  Next: Configuring keyword expansion,  Prev: Avoiding substitution,  Up: Keyword substitution

Substitution modes
==================

   Each file has a stored default substitution mode, and each working
directory copy of a file also has a substitution mode.  The former is
set by the `-k' option to `cvs add' and `cvs admin'; the latter is set
by the `-k' or `-A' options to `cvs checkout' or `cvs update'.  `cvs
diff' also has a `-k' option.  For some examples, see *Note Binary
files::, and *Note Merging and keywords::.

   The modes available are:

`-kkv'
     Generate keyword strings using the default form, e.g.  `$Revision:
     5.7 $' for the `Revision' keyword.

`-kkvl'
     Like `-kkv', except that a locker's name is always inserted if the
     given revision is currently locked.  The locker's name is only
     relevant if `cvs admin -l' is in use.

`-kk'
     Generate only keyword names in keyword strings; omit their values.
     For example, for the `Revision' keyword, generate the string
     `$Revision$' instead of `$Revision: 5.7 $'.  This option is useful
     to ignore differences due to keyword substitution when comparing
     different revisions of a file (*note Merging and keywords::).

`-ko'
     Generate the old keyword string, present in the working file just
     before it was checked in.  For example, for the `Revision'
     keyword, generate the string `$Revision: 1.1 $' instead of
     `$Revision: 5.7 $' if that is how the string appeared when the
     file was checked in.

`-kb'
     Like `-ko', but also inhibit conversion of line endings between
     the canonical form in which they are stored in the repository
     (linefeed only), and the form appropriate to the operating system
     in use on the client.  For systems, like unix, which use linefeed
     only to terminate lines, this is very similar to `-ko'.  For more
     information on binary files, see *Note Binary files::.  In CVS
     version 1.12.2 and later `-kb', as set by `cvs add', `cvs admin',
     or `cvs import' may not be overridden by a `-k' option specified
     on the command line.

`-kv'
     Generate only keyword values for keyword strings.  For example,
     for the `Revision' keyword, generate the string `5.7' instead of
     `$Revision: 5.7 $'.  This can help generate files in programming
     languages where it is hard to strip keyword delimiters like
     `$Revision: $' from a string.  However, further keyword
     substitution cannot be performed once the keyword names are
     removed, so this option should be used with care.

     One often would like to use `-kv' with `cvs export'--*note
     export::.  But be aware that doesn't handle an export containing
     binary files correctly.



File: cvs.info,  Node: Configuring keyword expansion,  Next: Log keyword,  Prev: Substitution modes,  Up: Keyword substitution

Configuring Keyword Expansion
=============================

   In a repository that includes third-party software on vendor
branches, it is sometimes helpful to configure CVS to use a local
keyword instead of the standard $Id$ or $Header$ keywords. Examples from
real projects include $Xorg$, $XFree86$, $FreeBSD$, $NetBSD$,
$OpenBSD$, and even $dotat$.  The advantage of this is that you can
include your local version information in a file using this local
keyword (sometimes called a "custom tag" or a "local tag") without
disrupting the upstream version information (which may be a different
local keyword or a standard keyword). In these cases, it is typically
desirable to disable the expansion of all keywords except the
configured local keyword.

   The `KeywordExpansion' option in the `CVSROOT/config' file is
intended to allow for the either the explicit exclusion of a keyword or
list of keywords, or for the explicit inclusion of a keyword or a list
of keywords. This list may include the `LocalKeyword' that has been
configured.

   The `KeywordExpansion' option is followed by `=' and the next
character may either be `i' to start an inclusion list or `e' to start
an exclusion list. If the following lines were added to the
`CVSROOT/config' file:

             # Add a "MyBSD" keyword and restrict keyword
             # expansion
             LocalKeyword=MyBSD=CVSHeader
             KeywordExpand=iMyBSD

   then only the $MyBSD$ keyword would be expanded.  A list may be
used. The this example:

             # Add a "MyBSD" keyword and restrict keyword
             # expansion to the MyBSD, Name and Date keywords.
             LocalKeyword=MyBSD=CVSHeader
             KeywordExpand=iMyBSD,Name,Date

   would allow $MyBSD$, $Name$, and $Date$ to be expanded.

   It is also possible to configure an exclusion list using the
following:

             # Do not expand the non-RCS keyword CVSHeader
             KeywordExpand=eCVSHeader

   This allows CVS to ignore the recently introduced $CVSHeader$
keyword and retain all of the others. The exclusion entry could also
contain the standard RCS keyword list, but this could be confusing to
users that expect RCS keywords to be expanded, so care should be taken
to properly set user expectations for a repository that is configured
in that manner.

   If there is a desire to not have any RCS keywords expanded and not
use the `-ko' flags everywhere, an administrator may disable all
keyword expansion using the `CVSROOT/config' line:

     	# Do not expand any RCS keywords
     	KeywordExpand=i

   this could be confusing to users that expect RCS keywords like $Id$
to be expanded properly, so care should be taken to properly set user
expectations for a repository so configured.

   It should be noted that a patch to provide both the `KeywordExpand'
and `LocalKeyword' features has been around a long time. However, that
patch implemented these features using `tag=' and `tagexpand=' keywords
and those keywords are NOT recognized.


File: cvs.info,  Node: Log keyword,  Prev: Configuring keyword expansion,  Up: Keyword substitution

Problems with the $Log$ keyword.
================================

   The `$Log$' keyword is somewhat controversial.  As long as you are
working on your development system the information is easily accessible
even if you do not use the `$Log$' keyword--just do a `cvs log'.  Once
you export the file the history information might be useless anyhow.

   A more serious concern is that CVS is not good at handling `$Log$'
entries when a branch is merged onto the main trunk.  Conflicts often
result from the merging operation.

   People also tend to "fix" the log entries in the file (correcting
spelling mistakes and maybe even factual errors).  If that is done the
information from `cvs log' will not be consistent with the information
inside the file.  This may or may not be a problem in real life.

   It has been suggested that the `$Log$' keyword should be inserted
_last_ in the file, and not in the files header, if it is to be used at
all.  That way the long list of change messages will not interfere with
everyday source file browsing.


File: cvs.info,  Node: Tracking sources,  Next: Builds,  Prev: Keyword substitution,  Up: Top

Tracking third-party sources
****************************

   If you modify a program to better fit your site, you probably want
to include your modifications when the next release of the program
arrives.  CVS can help you with this task.

   In the terminology used in CVS, the supplier of the program is
called a "vendor".  The unmodified distribution from the vendor is
checked in on its own branch, the "vendor branch".  CVS reserves branch
1.1.1 for this use.

   When you modify the source and commit it, your revision will end up
on the main trunk.  When a new release is made by the vendor, you
commit it on the vendor branch and copy the modifications onto the main
trunk.

   Use the `import' command to create and update the vendor branch.
When you import a new file, (usually) the vendor branch is made the
`head' revision, so anyone that checks out a copy of the file gets that
revision.  When a local modification is committed it is placed on the
main trunk, and made the `head' revision.

* Menu:

* First import::                Importing for the first time
* Update imports::              Updating with the import command
* Reverting local changes::     Reverting to the latest vendor release
* Binary files in imports::     Binary files require special handling
* Keywords in imports::         Keyword substitution might be undesirable
* Multiple vendor branches::    What if you get sources from several places?


File: cvs.info,  Node: First import,  Next: Update imports,  Up: Tracking sources

Importing for the first time
============================

   Use the `import' command to check in the sources for the first time.
When you use the `import' command to track third-party sources, the
"vendor tag" and "release tags" are useful.  The "vendor tag" is a
symbolic name for the branch (which is always 1.1.1, unless you use the
`-b BRANCH' flag--see *Note Multiple vendor branches::.).  The "release
tags" are symbolic names for a particular release, such as `FSF_0_04'.

   Note that `import' does _not_ change the directory in which you
invoke it.  In particular, it does not set up that directory as a CVS
working directory; if you want to work with the sources import them
first and then check them out into a different directory (*note Getting
the source::).

   Suppose you have the sources to a program called `wdiff' in a
directory `wdiff-0.04', and are going to make private modifications
that you want to be able to use even when new releases are made in the
future.  You start by importing the source to your repository:

     $ cd wdiff-0.04
     $ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04

   The vendor tag is named `FSF_DIST' in the above example, and the
only release tag assigned is `WDIFF_0_04'.


File: cvs.info,  Node: Update imports,  Next: Reverting local changes,  Prev: First import,  Up: Tracking sources

Updating with the import command
================================

   When a new release of the source arrives, you import it into the
repository with the same `import' command that you used to set up the
repository in the first place.  The only difference is that you specify
a different release tag this time:

     $ tar xfz wdiff-0.05.tar.gz
     $ cd wdiff-0.05
     $ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05

   *WARNING: If you use a release tag that already exists in one of the
repository archives, files removed by an import may not be detected.*

   For files that have not been modified locally, the newly created
revision becomes the head revision.  If you have made local changes,
`import' will warn you that you must merge the changes into the main
trunk, and tell you to use `checkout -j' to do so:

     $ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff

The above command will check out the latest revision of `wdiff',
merging the changes made on the vendor branch `FSF_DIST' since
yesterday into the working copy.  If any conflicts arise during the
merge they should be resolved in the normal way (*note Conflicts
example::).  Then, the modified files may be committed.

   However, it is much better to use the two release tags rather than
using a date on the branch as suggested above:

     $ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff

The reason this is better is that using a date, as suggested above,
assumes that you do not import more than one release of a product per
day.  More importantly, using the release tags allows CVS to detect
files that were removed between the two vendor releases and mark them
for removal.  Since `import' has no way to detect removed files, you
should do a merge like this even if `import' doesn't tell you to.


File: cvs.info,  Node: Reverting local changes,  Next: Binary files in imports,  Prev: Update imports,  Up: Tracking sources

Reverting to the latest vendor release
======================================

   You can also revert local changes completely and return to the
latest vendor release by changing the `head' revision back to the
vendor branch on all files.  For example, if you have a checked-out
copy of the sources in `~/work.d/wdiff', and you want to revert to the
vendor's version for all the files in that directory, you would type:

     $ cd ~/work.d/wdiff
     $ cvs admin -bFSF_DIST .

You must specify the `-bFSF_DIST' without any space after the `-b'.
*Note admin options::.


File: cvs.info,  Node: Binary files in imports,  Next: Keywords in imports,  Prev: Reverting local changes,  Up: Tracking sources

How to handle binary files with cvs import
==========================================

   Use the `-k' wrapper option to tell import which files are binary.
*Note Wrappers::.


File: cvs.info,  Node: Keywords in imports,  Next: Multiple vendor branches,  Prev: Binary files in imports,  Up: Tracking sources

How to handle keyword substitution with cvs import
==================================================

   The sources which you are importing may contain keywords (*note
Keyword substitution::).  For example, the vendor may use CVS or some
other system which uses similar keyword expansion syntax.  If you just
import the files in the default fashion, then the keyword expansions
supplied by the vendor will be replaced by keyword expansions supplied
by your own copy of CVS.  It may be more convenient to maintain the
expansions supplied by the vendor, so that this information can supply
information about the sources that you imported from the vendor.

   To maintain the keyword expansions supplied by the vendor, supply
the `-ko' option to `cvs import' the first time you import the file.
This will turn off keyword expansion for that file entirely, so if you
want to be more selective you'll have to think about what you want and
use the `-k' option to `cvs update' or `cvs admin' as appropriate.


File: cvs.info,  Node: Multiple vendor branches,  Prev: Keywords in imports,  Up: Tracking sources

Multiple vendor branches
========================

   All the examples so far assume that there is only one vendor from
which you are getting sources.  In some situations you might get
sources from a variety of places.  For example, suppose that you are
dealing with a project where many different people and teams are
modifying the software.  There are a variety of ways to handle this,
but in some cases you have a bunch of source trees lying around and
what you want to do more than anything else is just to all put them in
CVS so that you at least have them in one place.

   For handling situations in which there may be more than one vendor,
you may specify the `-b' option to `cvs import'.  It takes as an
argument the vendor branch to import to.  The default is `-b 1.1.1'.

   For example, suppose that there are two teams, the red team and the
blue team, that are sending you sources.  You want to import the red
team's efforts to branch 1.1.1 and use the vendor tag RED.  You want to
import the blue team's efforts to branch 1.1.3 and use the vendor tag
BLUE.  So the commands you might use are:

     $ cvs import dir RED RED_1-0
     $ cvs import -b 1.1.3 dir BLUE BLUE_1-5

   Note that if your vendor tag does not match your `-b' option, CVS
will not detect this case!  For example,

     $ cvs import -b 1.1.3 dir RED RED_1-0

Be careful; this kind of mismatch is sure to sow confusion or worse.  I
can't think of a useful purpose for the ability to specify a mismatch
here, but if you discover such a use, don't.  CVS is likely to make this
an error in some future release.


File: cvs.info,  Node: Builds,  Next: Special Files,  Prev: Tracking sources,  Up: Top

How your build system interacts with CVS
****************************************

   As mentioned in the introduction, CVS does not contain software for
building your software from source code.  This section describes how
various aspects of your build system might interact with CVS.

   One common question, especially from people who are accustomed to
RCS, is how to make their build get an up to date copy of the sources.
The answer to this with CVS is two-fold.  First of all, since CVS
itself can recurse through directories, there is no need to modify your
`Makefile' (or whatever configuration file your build tool uses) to
make sure each file is up to date.  Instead, just use two commands,
first `cvs -q update' and then `make' or whatever the command is to
invoke your build tool.  Secondly, you do not necessarily _want_ to get
a copy of a change someone else made until you have finished your own
work.  One suggested approach is to first update your sources, then
implement, build and test the change you were thinking of, and then
commit your sources (updating first if necessary).  By periodically (in
between changes, using the approach just described) updating your
entire tree, you ensure that your sources are sufficiently up to date.

   One common need is to record which versions of which source files
went into a particular build.  This kind of functionality is sometimes
called "bill of materials" or something similar.  The best way to do
this with CVS is to use the `tag' command to record which versions went
into a given build (*note Tags::).

   Using CVS in the most straightforward manner possible, each
developer will have a copy of the entire source tree which is used in a
particular build.  If the source tree is small, or if developers are
geographically dispersed, this is the preferred solution.  In fact one
approach for larger projects is to break a project down into smaller
separately-compiled subsystems, and arrange a way of releasing them
internally so that each developer need check out only those subsystems
which they are actively working on.

   Another approach is to set up a structure which allows developers to
have their own copies of some files, and for other files to access
source files from a central location.  Many people have come up with
some such a system using features such as the symbolic link feature
found in many operating systems, or the `VPATH' feature found in many
versions of `make'.  One build tool which is designed to help with this
kind of thing is Odin (see
`ftp://ftp.cs.colorado.edu/pub/distribs/odin').


File: cvs.info,  Node: Special Files,  Next: CVS commands,  Prev: Builds,  Up: Top

Special Files
*************

   In normal circumstances, CVS works only with regular files.  Every
file in a project is assumed to be persistent; it must be possible to
open, read and close them; and so on.  CVS also ignores file
permissions and ownerships, leaving such issues to be resolved by the
developer at installation time.  In other words, it is not possible to
"check in" a device into a repository; if the device file cannot be
opened, CVS will refuse to handle it.  Files also lose their ownerships
and permissions during repository transactions.


File: cvs.info,  Node: CVS commands,  Next: Invoking CVS,  Prev: Special Files,  Up: Top

Guide to CVS commands
*********************

   This appendix describes the overall structure of CVS commands, and
describes some commands in detail (others are described elsewhere; for
a quick reference to CVS commands, *note Invoking CVS::).

* Menu:

* Structure::                   Overall structure of CVS commands
* Exit status::                 Indicating CVS's success or failure
* ~/.cvsrc::                    Default options with the ~/.cvsrc file
* Global options::              Options you give to the left of cvs_command
* Common options::              Options you give to the right of cvs_command
* Date input formats::		Acceptable formats for date specifications
* admin::                       Administration
* annotate::                    What revision modified each line of a file?
* checkout::                    Checkout sources for editing
* commit::                      Check files into the repository
* diff::                        Show differences between revisions
* export::                      Export sources from CVS, similar to checkout
* history::                     Show status of files and users
* import::                      Import sources into CVS, using vendor branches
* log::                         Show log messages for files
* ls & rls::                    List files in the repository
* rdiff::                       'patch' format diffs between releases
* release::                     Indicate that a directory is no longer in use
* update::                      Bring work tree in sync with repository


File: cvs.info,  Node: Structure,  Next: Exit status,  Up: CVS commands

Overall structure of CVS commands
=================================

   The overall format of all CVS commands is:

     cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]

`cvs'
     The name of the CVS program.

`cvs_options'
     Some options that affect all sub-commands of CVS.  These are
     described below.

`cvs_command'
     One of several different sub-commands.  Some of the commands have
     aliases that can be used instead; those aliases are noted in the
     reference manual for that command.  There are only two situations
     where you may omit `cvs_command': `cvs -H' elicits a list of
     available commands, and `cvs -v' displays version information on
     CVS itself.

`command_options'
     Options that are specific for the command.

`command_args'
     Arguments to the commands.

   There is unfortunately some confusion between `cvs_options' and
`command_options'.  When given as a `cvs_option', some options only
affect some of the commands.  When given as a `command_option' it may
have a different meaning, and be accepted by more commands.  In other
words, do not take the above categorization too seriously.  Look at the
documentation instead.


File: cvs.info,  Node: Exit status,  Next: ~/.cvsrc,  Prev: Structure,  Up: CVS commands

CVS's exit status
=================

   CVS can indicate to the calling environment whether it succeeded or
failed by setting its "exit status".  The exact way of testing the exit
status will vary from one operating system to another.  For example in
a unix shell script the `$?' variable will be 0 if the last command
returned a successful exit status, or greater than 0 if the exit status
indicated failure.

   If CVS is successful, it returns a successful status; if there is an
error, it prints an error message and returns a failure status.  The
one exception to this is the `cvs diff' command.  It will return a
successful status if it found no differences, or a failure status if
there were differences or if there was an error.  Because this behavior
provides no good way to detect errors, in the future it is possible that
`cvs diff' will be changed to behave like the other CVS commands.


File: cvs.info,  Node: ~/.cvsrc,  Next: Global options,  Prev: Exit status,  Up: CVS commands

Default options and the ~/.cvsrc file
=====================================

   There are some `command_options' that are used so often that you
might have set up an alias or some other means to make sure you always
specify that option.  One example (the one that drove the
implementation of the `.cvsrc' support, actually) is that many people
find the default output of the `diff' command to be very hard to read,
and that either context diffs or unidiffs are much easier to understand.

   The `~/.cvsrc' file is a way that you can add default options to
`cvs_commands' within cvs, instead of relying on aliases or other shell
scripts.

   The format of the `~/.cvsrc' file is simple.  The file is searched
for a line that begins with the same name as the `cvs_command' being
executed.  If a match is found, then the remainder of the line is split
up (at whitespace characters) into separate options and added to the
command arguments _before_ any options from the command line.

   If a command has two names (e.g., `checkout' and `co'), the official
name, not necessarily the one used on the command line, will be used to
match against the file.  So if this is the contents of the user's
`~/.cvsrc' file:

     log -N
     diff -uN
     rdiff -u
     update -Pd
     checkout -P
     release -d

the command `cvs checkout foo' would have the `-P' option added to the
arguments, as well as `cvs co foo'.

   With the example file above, the output from `cvs diff foobar' will
be in unidiff format.  `cvs diff -c foobar' will provide context diffs,
as usual.  Getting "old" format diffs would be slightly more
complicated, because `diff' doesn't have an option to specify use of
the "old" format, so you would need `cvs -f diff foobar'.

   In place of the command name you can use `cvs' to specify global
options (*note Global options::).  For example the following line in
`.cvsrc'

     cvs -z6

causes CVS to use compression level 6.

